<!DOCTYPE html>
<html lang="en">

<head>
	<title> Space game </title>
	<!-- Jingcheng Shi -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		padding: 0;
		margin: 0;
		overflow: hidden;
	}
	</style>
</head>

<body>

	<div id="container"></div>

	<script src="js/three.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="./js/GPUParticleSystem.js"></script>


	<script id="vertexShader" type="x-shader/x-vertex">

	void main(){
		gl_Position = vec4(position, 1.0);
	}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">

	precision highp float;

	uniform vec2 iResolution;
	uniform float iTime;

	void main()
	{
		float time = (iTime+29.) * 60.0;

		float s = 0.0, v = 0.0;
		vec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;
		float t = time*0.005;
		uv.x = (uv.x * iResolution.x / iResolution.y) + sin(t) * 0.5;
		float si = sin(t + 2.17); // ...Squiffy rotation matrix!
		float co = cos(t);
		uv *= mat2(co, si, -si, co);
		vec3 col = vec3(0.0);
		vec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);
		for (int r = 0; r < 100; r++)
		{
			vec3 p = init + s * vec3(uv, 0.143);
			p.z = mod(p.z, 2.0);
			for (int i=0; i < 10; i++)	p = abs(p * 2.04) / dot(p, p) - 0.75;
			v += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;
			// Get a purple and cyan effect by biasing the RGB in different ways...
			col +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;
			s += .01;
		}
		gl_FragColor = vec4(col, 1.0);

	}

	</script>



	<script>

	var container, stats;
	var camera, scene, renderer;
	var uniforms;
	var clock = new THREE.Clock();
	var mesh_tp, tp_in = true;
	var gui = new dat.GUI( { width: 279 } );
	var controls;
	var tick = 0;
	var options, spawnerOptions, particleSystem;

	init();
	animate();
	animateParticleStars();

	function init() {

		container = document.getElementById('container');


		camera = new THREE.PerspectiveCamera();
		camera.position.z = 5;

		scene = new THREE.Scene();
		scene_main = new THREE.Scene();
		var main_color = new THREE.Color( 0x000000 ); //backgroud is black now
		scene_main.background = main_color;

		stats = new Stats();
		container.appendChild(stats.dom);

		//var channelTex = new THREE.TextureLoader().load('tex.png');
		var geometry = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight);

		uniforms = {
			iTime: { type: "f", value: 1.0 },
			//iChannel0: {type:'t', value: channelTex },
			iResolution: { type: "v2", value: new THREE.Vector2() }
		};

		var material = new THREE.ShaderMaterial({

			uniforms: uniforms,
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent

		});

		var mesh_tp = new THREE.Mesh(geometry, material);
		mesh_tp.name = 'tp';
		scene.add(mesh_tp);

		////////////////////////////////////////////////////////////////////////////////
		//															PLANET STUFF																	//
		////////////////////////////////////////////////////////////////////////////////

		/////////////////
		////  LIGHTS ////
		/////////////////
		var ambientLight = new THREE.AmbientLight(0xFFFFFF);
		scene_main.add(ambientLight);
		var spotlight = new THREE.DirectionalLight(0xFFFFFF);
		spotlight.position.set(50,50,50);
		scene_main.add(spotlight);
		/////////////////
		///  OBJECTS ////
		/////////////////
		var earthGeometry = new THREE.SphereGeometry(10, 50, 50);
		var earthMaterial = new THREE.MeshPhongMaterial({
			map: new THREE.TextureLoader().load('img/earth_texture.jpg'),
			bumpMap : new THREE.TextureLoader().load('img/earthbump1k.jpg'),
			bumpScale : 0.7,
			color: 0xf1f1f1
		});
		var earth = new THREE.Mesh(earthGeometry, earthMaterial);
		earth.position.set(0,0,-45);
		scene_main.add(earth);
		//Clouds
		var cloudGeometry = new THREE.SphereGeometry(10.3,  50, 50);
		var cloudMaterial = new THREE.MeshPhongMaterial({
			map: new THREE.TextureLoader().load('img/clouds.jpg'),
			transparent: true,
			opacity: 0.3
		});
		var clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
		clouds.position.set(0,0,-45);
		scene_main.add(clouds);
		//Moon
		var moonGeometry = new THREE.SphereGeometry(4, 60,60);
		var moonMaterial = new THREE.MeshPhongMaterial({
			map: new THREE.TextureLoader().load('img/moon_texture.jpg')
		});
		var moon = new THREE.Mesh(moonGeometry, moonMaterial);
		moon.position.set(18,6,-40);
		scene_main.add(moon);
		var r = 22;
		var theta = 0;
		var dTheta = 2 * Math.PI / 1000;
		var earthVec = new THREE.Vector3(0,0,0);
		//camera.lookAt(earthVec);

		////////////////////////////////////////////////////////////////////////////////
		//													END PLANET STUFF																	//
		////////////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////
		//											PARTICLE SYSTEM STUFF																	//
		////////////////////////////////////////////////////////////////////////////////
        
		var textureLoader = new THREE.TextureLoader();

		particleSystem = new THREE.GPUParticleSystem( {
			maxParticles: 250000,
			particleNoiseTex: textureLoader.load( 'perlin-512.png' ),
			particleSpriteTex: textureLoader.load( 'star.png' )
		} );

		scene_main.add(particleSystem);


		options = {
			position: new THREE.Vector3(0,30,0),
			positionRandomness: 50,
			velocity: new THREE.Vector3(0, 0 ,0),
			velocityRandomness: 0.1,
			//color: 0xaa88ff,
			colorRandomness: .0,
			turbulence: 0.1,
			lifetime: 2,
			size: 46,
			sizeRandomness: 1
		};

		spawnerOptions = {
			spawnRate: 2500,
			horizontalSpeed: 1.0,
			verticalSpeed: 1.0,
			timeScale: 0.2
		};

		//

		gui.add( options, "velocityRandomness", 0, 2 );
		gui.add( options, "size", 1, 60 );
		gui.add( options, "sizeRandomness", 0, 25 );
		gui.add( options, "colorRandomness", 0, 1 );
		gui.add( options, "lifetime", .1, 8 );
		gui.add( options, "turbulence", 0, 0.6 );

		gui.add( spawnerOptions, "spawnRate", 500, 3500 );
		gui.add( spawnerOptions, "timeScale", -1, 1 );

		//

		stats = new Stats();
		container.appendChild( stats.dom );

		////////////////////////////////////////////////////////////////////////////////
		//												END PARTICLE SYSTEM STUFF														//
		////////////////////////////////////////////////////////////////////////////////

        			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

		// renderer = new THREE.WebGLRenderer();
		// renderer.setClearColor(0x000000);
		// container.appendChild(renderer.domElement);
		// // START PARTICLE STUFF
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		// END STAR PARTICLE STUFF

		onWindowResize();

		window.addEventListener('resize', onWindowResize, false);

	}

	function onWindowResize(event) {
		uniforms.iResolution.value.x = window.innerWidth;
		uniforms.iResolution.value.y = window.innerHeight;
		camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {

		requestAnimationFrame(animate);

		render();
		stats.update();
	}

	function animateParticleStars() {

		requestAnimationFrame( animate );

		controls.update();

		var delta = clock.getDelta() * spawnerOptions.timeScale;

		tick += delta;

		if ( tick < 0 ) tick = 0;

		if ( delta > 0 ) {

			options.position.x = Math.sin( tick * spawnerOptions.horizontalSpeed ) * 5;
			options.position.y = Math.sin( tick * spawnerOptions.verticalSpeed ) * 5;
			options.position.z = Math.sin( tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed ) * 3;

			for ( var x = 0; x < spawnerOptions.spawnRate * delta; x++ ) {

				// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
				// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below

				particleSystem.spawnParticle( options );

			}

		}

		particleSystem.update( tick );

		render();

		stats.update();

	}

	function render() {
		uniforms.iTime.value += clock.getDelta();
		// if(uniforms.iTime.value > 5 && tp_in){
		// 	removeTp();
		// 	tp_in = false;
		// }
		if(uniforms.iTime.value > 5){
			renderer.render(scene_main,camera);
		}else{
			renderer.render(scene, camera);
		}

	}

	// function removeTp() {
	// 	var selectedObject = scene.getObjectByName(tp);
	// 	scene.remove(selectedObject);
	// }

	</script>
</body>

</html>
